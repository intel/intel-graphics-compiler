; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
;=========================== begin_copyright_notice ============================
;
; Copyright (C) 2024 Intel Corporation
;
; SPDX-License-Identifier: MIT
;
;============================ end_copyright_notice =============================

; UNSUPPORTED: llvm-17-plus
; RUN: igc_opt --typed-pointers %s -S -o - -types-legalization-pass | FileCheck %s

; should replace phi instruction with alloca store and load instructions

define spir_kernel void @cover.ResolvePhiNode(i1 %cc) {
; CHECK-LABEL: define spir_kernel void @cover.ResolvePhiNode(
; CHECK-SAME: i1 [[CC:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = alloca [4 x i32], align 4
; CHECK-NEXT:    br i1 [[CC]], label %[[FIRST:.*]], label %[[SECOND:.*]]
; CHECK:       [[FIRST]]:
; CHECK-NEXT:    [[A:%.*]] = insertvalue [4 x i32] undef, i32 13, 0
; CHECK-NEXT:    [[TMP1:%.*]] = getelementptr [4 x i32], [4 x i32]* [[TMP0]], i32 0, i32 0
; CHECK-NEXT:    store i32 13, i32* [[TMP1]], align 4
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr [4 x i32], [4 x i32]* [[TMP0]], i32 0, i32 1
; CHECK-NEXT:    store i32 undef, i32* [[TMP2]], align 4
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr [4 x i32], [4 x i32]* [[TMP0]], i32 0, i32 2
; CHECK-NEXT:    store i32 undef, i32* [[TMP3]], align 4
; CHECK-NEXT:    [[TMP4:%.*]] = getelementptr [4 x i32], [4 x i32]* [[TMP0]], i32 0, i32 3
; CHECK-NEXT:    store i32 undef, i32* [[TMP4]], align 4
; CHECK-NEXT:    br label %[[EXIT:.*]]
; CHECK:       [[SECOND]]:
; CHECK-NEXT:    [[B:%.*]] = insertvalue [4 x i32] undef, i32 144, 0
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr [4 x i32], [4 x i32]* [[TMP0]], i32 0, i32 0
; CHECK-NEXT:    store i32 144, i32* [[TMP5]], align 4
; CHECK-NEXT:    [[TMP6:%.*]] = getelementptr [4 x i32], [4 x i32]* [[TMP0]], i32 0, i32 1
; CHECK-NEXT:    store i32 undef, i32* [[TMP6]], align 4
; CHECK-NEXT:    [[TMP7:%.*]] = getelementptr [4 x i32], [4 x i32]* [[TMP0]], i32 0, i32 2
; CHECK-NEXT:    store i32 undef, i32* [[TMP7]], align 4
; CHECK-NEXT:    [[TMP8:%.*]] = getelementptr [4 x i32], [4 x i32]* [[TMP0]], i32 0, i32 3
; CHECK-NEXT:    store i32 undef, i32* [[TMP8]], align 4
; CHECK-NEXT:    br label %[[EXIT]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    [[TMP9:%.*]] = load [4 x i32], [4 x i32]* [[TMP0]], align 4
; CHECK-NEXT:    ret void
;
entry:
  br i1 %cc, label %first, label %second
first:
  %a = insertvalue [4 x i32] undef, i32 13, 0
  br label %exit
second:
  %b = insertvalue [4 x i32] undef, i32 144, 0
  br label %exit
exit:
  %result = phi [4 x i32] [%a, %first], [%b, %second]
  ret void
}
